# HW-6


## فاز اول

### Overview
در این بخش قرار بود تا با استفاده از دو الگوی طراحی گفته شده یک سیستم اطلاع رسانی به شهروندان برای اعلام میزان فاصله و هزینه میان شهرها با استفاده از روش TDD بسازیم. ماحصل کار ما کلاس NotificationSystem است که شامل فیلدهای زیر می‌باشد:
- Graph graph;
- State state;
- Strategy strategy;
- Integer trainSpeed;

همچنین این کلاس دارای متدهای زیر است:
- public void toggleDirection()
- public Integer calculateDistance(Node source, Node destination)
- public boolean existPath(Node source, Node destination, Node hatedCity)
- public StrategyApproach getFasterTransport(Node source, Node destination)

حال به بررسی هر کدام از خواسته های این فاز میپردازیم:

### استفاده از الگوی طراحی State
در این سناریو تمامی یال‌های بین شهری یا در حالت یک‌طرفه قرار داشتند یا دوطرفه. بنابراین انگار برای شهر ما دو State (جهت‌دار، بی‌جهت) وجود داشت و براساس اینکه در کدام State هستیم، نحوه  toggleDirection متفاوتی برای پیاده‌سازی داشتیم. بنابراین از آنجا که شامل تعدادی State بودیم که هر یک دارای رفتار متفاوتی برای پیاده‌سازی این تابع بود، به سراغ الگوی طراحی State رفتیم. بنابراین یک اینترفیس State تعریف کردیم که دو متد toggleDirection(Graph graph) و nextState() را پیاده‌سازی کرده بود و سپس دو کلاس UnidirectionalState و BidirectionalState را با ارث‌بری از این اینترفیس پیاده‌سازی کردیم. بنابراین یک فیلد state در کلاس اصلی ما وجود خواهد داشت و برای پیاده‌سازی toggleDirection در این کلاس، دو خط state.toggleDirection(graph) و سپس state = state.nextState() اجرا می‌شوند.

### استفاده از الگوی طراحی Strategy
در این مسئله براساس خواسته کاربر که می‌خواست کوتاه‌ترین مسیر به وسیله قطار یا اتوبوس را پیدا کند، مجبور به استفاده از دو الگوریتم متفاوت جستجوی کوتاه‌ترین مسیر در گراف می‌شدیم. بنابراین از آنجا که با دو الگوریتم متفاوت که هر دو مربوط به پیدا کردن کوتاه‌ترین مسیر در گراف بودند، سروکار داشتیم و این دو خروجی یکسانی اما پیاده‌سازی متفاوتی داشتند، به سراغ الگوی طراحی Strategy رفتیم. بنابراین یک اینترفیس Strategy معرفی کردیم که متد calculateDistance و existPath را داشت و سپس دو کلاس BusStrategy و TrainStrategy را با ارث‌بری از این اینترفیس پیاده‌سازی کردیم. حال یک فیلد strategy در کلاس اصلی ما وجود دارد و بسته به خواسته کاربر، استراتژی مدنظر را ست کرده و خواسته کاربر را توسط استراتژی مدنظر اجرا می‌کنیم.

### استفاده از TDD
از آنجا که هر کدام از خواسته‌های این فاز یا ربطی به State داشتند یا ربطی به Strategy، ما دو فایل StateTest و StrategyTest را ساختیم و برای اضافه کردن هر فیچر به داخل کلاسمان، ابتدا تست‌های آن فیچر و تابع خالی مربوط به آن فیچر را به صورتی که کامپایل ارور نخوریم نوشتیم و سپس به نحوی آن فیچر را پیاده‌سازی کردیم که تست‌های مربوطه پاس شود. نحوه انجام این کار در کامیت‌های زده شده در ریپازیتوری مشخص است و می‌توانید با مراجعه به آن، جزئیات بیشتری را مشاهده کنید.

### اجرای برنامه
در آخر می‌توانید گراف مدنظر خود را در main ساخته و با تغییرات کوچکی مربوط به گراف مدنظر که در کد مشخص هستند، main را اجرا کنید که به شما کامند لاینی برای اجرای درخواست‌های گفته شده در سوال را می‌دهد.

<h2>فاز دوم</h2>

Facade Design Pattern

Facade یک الگوی طراحی ساختاری است که یک رابط ساده‌شده برای یک کتابخانه، یک چارچوب، یا هر مجموعه پیچیده‌ای از کلاس‌ها فراهم می‌کند. ما دو بخش از کد را شناسایی کرده‌ایم که می‌توانند با استفاده از این الگو بازسازی شوند:

CodeGeneratorFacade

قبل از بازسازی، کلاس Parser به طور مستقیم از قابلیت‌های کلاس codeGenerator استفاده می‌کرد. پس از بازسازی، ما یک Facade برای CodeGenerator اضافه کردیم تا کلاس Parser تنها از قابلیت‌های موجود در کلاس CodeGeneratorFacade استفاده کند و به این ترتیب رابط موجود را محدود و ساده کردیم. در نهایت، ما همچنین استفاده‌ها را تغییر دادیم تا کد را با اقدامات بازسازی هماهنگ کنیم.

ScannerFacade

قبل از بازسازی، کلاس Parser به طور مستقیم از قابلیت‌های lexicalAnalyzer استفاده می‌کرد. پس از بازسازی، ما یک Facade برای scanner اضافه کردیم تا کلاس Parser تنها از قابلیت‌های موجود در کلاس ScannerFacade استفاده کند و به این ترتیب رابط موجود را محدود و ساده کردیم. در نهایت، ما همچنین استفاده‌ها را تغییر دادیم تا کد را با اقدامات بازسازی هماهنگ کنیم.

Polymorphism:

در زبان‌های برنامه‌نویسی و نظریه نوع‌ها، Polymorphism به فراهم کردن یک رابط واحد برای موجودیت‌هایی با نوع‌های مختلف یا استفاده از یک نماد واحد برای نمایش چند نوع مختلف اشاره دارد. یکی از نشانه‌های رایج بازسازی با استفاده از Polymorphism وجود سناریوهای متعدد switch case است. با توجه به این توضیح، ما این الگوی ضد را در کلاس Action شناسایی کردیم و آن را بازسازی کردیم. در این فرآیند، برای هر switch case موجود برای اکشن‌ها یک کلاس منحصر به فرد ایجاد کردیم؛ کلاس‌های shift، accept و reduce ایجاد شدند و همه این قابلیت‌های مرتبط با اکشن‌ها را به یک بسته actions منتقل کردیم. در نهایت، ما همچنین استفاده‌ها را تغییر دادیم تا کد را با اقدامات بازسازی هماهنگ کنیم.

Separate Query From Modifier:

این تکنیک بازسازی، Command و Query Responsibility Segregation را پیاده‌سازی می‌کند. این اصل به ما می‌گوید که کد مسئول دریافت داده‌ها را از کدی که چیزی را داخل یک شیء تغییر می‌دهد جدا کنیم. یکی از بوی بدهایی که در کد شناسایی شد مربوط به این الگو، در کلاس SymbolTable در تابع getNextParameter بود، جایی که مقدار پارامتر قبلی دریافت می‌شد و پارامتر بعدی در همان تابع بازبینی می‌شد. برای بهبود این فرآیند، ما تابع دیگری به نام getCurrentParamIndex اضافه کردیم تا Query را از Modifier جدا کنیم.

Self Encapsulated Field

در این روش بازسازی و در این بخش از پروژه بازسازی minijava، ما خواص کلاس را به صورت private تعریف می‌کنیم و آنها را نیز به صورت private فراخوانی می‌کنیم. ما از متدهای Getter و Setter استفاده می‌کنیم تا اطمینان حاصل شود که تمام عملیات روی خواص از طریق متدها انجام می‌شود و نه از طریق دسترسی مستقیم به خواص. ما Getter و Setter با نام‌های getterMemory و setterMemory را به کلاس symbolTable اضافه کردیم.

<h3>تغییر ندادن مقدار پارامترهای توابع</h3>

<p>در این بازآرایی کد اجازه نمی‌دهیم مقداری که پارامتر یک تابع به خود گرفته است، تغییر کند. به جای آن یک متغیر جدید تعریف می‌کنیم و مقداری که می‌خواستیم به پارامتر بدهیم را به آن متغیر می‌دهیم. به این ترتیب کد هم خواناتر می‌شود و هم می‌توان بعدا راحت‌تر در آن تغییرات را اعمال کرد. به طور خاص، در فایل ParsTable.java مقدار پارامتر تابع jsonTable عوض می‌شود که ما آن را اصلاح کرده‌ایم.</p>

<h3>استخراج توابع</h3>

<p>قسمت‌هایی از کد هستند که در چند جا تکرار شده‌اند و می‌توان برای جلوگیری از این تکرارها آن‌ها را استخراج کرد و یک تابع جدید تشکیل داد تا در مواقع لزوم صدا زده شود. به بیان دیگر، می‌توان حجم کد را کاهش داد و هم‌زمان آن را برای ناظران خواناتر کرد. به طور خاص، در کلاس CodeGenerator بخشی از کد سه بار تکرار شده‌بود! با استخراج تابع مناسب آن را در مواقع لزوم صدا زدیم.</p>

<h2>پرسش‌ها</h2>

<h3>پرسش اول</h3>

- دسته‌ی اول Creational Patterns هستند. این الگوها روی ساخته شدن اشیا تمرکز می‌کنند. هدف آن است که با مدیریت نحوه‌ی ایجاد و ترکیب شدن اشیا از ایجاد اشیاء غیرضروری و یا وقوع پیچیدگی‌ها جلوگیری شود. همچنین مهم است که ساخت اشیا و کلیت سامانه از یکدیگر مستقل باشند.
- دسته‌ی دوم structural Patterns هستند. این الگوها روی ارتبط‌ها و ترکیب شدن‌های کلاس‌های گوناگون تمرکز می‌کنند. هدف آن است که ساختارهای بزرگ‌تر به نحوی ایجاد شوند که با اعمال تغییرات کوچک در بخش‌های کوچک‌ترشان، کلیت عملکرد سامانه تغییر نکند.
- دسته‌ی سوم Behavioral Patterns هستند. این الگوها تعامل‌های میان اشیاء را مدیریت می‌کنند تا رفتار آن‌ها در موقعیت‌های گوناگون بهینه شود. تقسیم مسئولیت‌ها میان اشیاء گوناگون و پرتعداد و همچنین مدیریت جریان کنترل در سامانه‌های پیچیده از مسئولیت‌های این الگوهاست.

<h3>پرسش دوم</h3>

<p>الگوهای State و Strategy هر دو مربوط به الگوهای Behavioral هستند. در الگوی استراتژی از میان روش‌های گوناگون برای انجام یک کار به شکل پویا و مستقل از کاربر یکی انتخاب می‌شود. این موضوع نشان‌دهنده‌ی مدیریت جریان کنترل و همچنین توزیع مسئولیت‌ها میان اشیاء است که مربوط به الگوهای رفتاری می‌شود. در الگوی استیت رفتار یک شیء بر اساس وضعیت داخلی آن در موقعیت‌های مختلف تغییر می‌کند. مشخصا این الگو هم با رفتار اشیاء درگیر است و مربوط به الگوهای رفتاری می‌شود.</p>

<h3>پرسش سوم</h3>

در این سناریو تمامی یال‌های بین شهری یا در حالت یک‌طرفه قرار داشتند یا دوطرفه. بنابراین انگار برای شهر ما دو **State** (جهت‌دار، بی‌جهت) وجود داشت و براساس اینکه در کدام State هستیم، نحوه  `toggleDirection` متفاوتی برای پیاده‌سازی داشتیم. بنابراین از آنجا که شامل تعدادی State بودیم که هر یک دارای رفتار متفاوتی برای پیاده‌سازی این تابع بود، به سراغ الگوی طراحی **State** رفتیم. بنابراین یک اینترفیس `State` تعریف کردیم که دو متد `toggleDirection(Graph graph)` و `nextState()` را پیاده‌سازی کرده بود و سپس دو کلاس `UnidirectionalState` و `BidirectionalState` را با ارث‌بری از این اینترفیس پیاده‌سازی کردیم. بنابراین یک فیلد `state` در کلاس اصلی ما وجود خواهد داشت و برای پیاده‌سازی `toggleDirection` در این کلاس، دو خط `state.toggleDirection(graph)` و سپس `state = state.nextState()` اجرا می‌شوند.

<h3>پرسش چهارم</h3>

- اصل SRP: معمولا این الگو مانع از تحقق این اصل می‌شود. البته دقت کنید که این موضوع قطعی نیست. برای توضیح بیش‌تر توجه کنید که رفتار بر اساس این الگو باعث می‌شود که معمولا یک کلاس علاوه بر وظیفه‌ی مدیریت کردن ایجاد نمونه‌ها وظایف دیگری مثل مدیریت منطق و ... را هم بر عهده بگیرد.
- اصل OCP: توسعه دادن یک کلاسی که با الگوی سینگلتون ساخته شده‌است، معمولا کار ساده‌ای نیست. پس وقوع این اصل زیر سوال قرار می‌گیرد. اگر لازم باشد به یک کلاس سینگلتون یک رفتار جدید اضافه کنیم، معمولا لازم می‌شود تغییرات در آن اعمال کنیم که این اصل را نقض می‌کند.
-  اصل LSP: یک کلاس با الگوی سینگلتون ممکن است این اصل را نقض کند. اگر رفتار یک کلاس با الگوی سینگلتون به پیاده‌سازی آن وابستگی زیادی داشته‌باشد، ممکن است وقوع این اصل به خطر بیفتد.
- اصل ISP: این اصل از نظر تئوری با کلاس‌های سینگلتون سازگار است. یعنی در حالت کلی می‌توان گفت که وقوعش با چالش مواجه نمی‌شود. در حالتی که یک واسط بیش از حد بزرگ توسط این کلاس پیاده‌سازی شود امکان وقوع اصل زیر سوال می‌رود.
- اصل DIP: یک کلاس مطابق با الگوی سینگلتون می‌تواند اصل DIP را نقض کند، زیرا در بیش‌تر اوقات به کلاس‌های خاصی وابسته می‌شود. یعنی به جای این که به انتزاع‌ها تکیه کند، به کلاس‌ها وابسته می‌شود و اصل را به حاشیه می‌برد.. از آن جا که Singleton مدیریت ایجاد نمونه‌ی خود را بر عهده دارد و ممکن است از تزریق وابستگی‌ها پشتیبانی نکند، این مسئله می‌تواند جایگزینی یا مثلا ساختن وابستگی‌ها برای آزمون را سخت‌تر کند.

<h3>پرسش پنجم</h3>

- کد تمیز کدی است که به راحتی قابل خواندن، فهمیدن، نگهداری، و همچنین توسعه باشد. همجنین لازم است از اصول و شیوه‌های بهینه‌ای که برنامه‌نویسی وجود دارند هم پیروی کند.
- گاهی اوقات به دلیل برخی از تصمیمات ناپایداری که به هنگام توسعه‌ی یک محصول گرفته می‌شوند، هزینه‌های اضافه‌ای به محصول تحمیل می‌شود که برای عملکرد بهتر سامانه لازم است در آینده ویرایش شوند. به این موارد اصطلاحا بدهی فنی می‌گویند.
- گاهی اوقات کد یک سامانه در ظاهر مناسب است اما نشانه‌هایی  در کد هستند که حاکی از مشکلات یا نقص‌های پنهان در طراحی هستند و ممکن است در آینده نیاز به بازنگری و بهبود داشته باشند. به این نشانه‌ها اصطلاحا بوی بد گفته می‌شود.

<h3>پرسش ششم</h3>

- Bloaters: در این بوی بد، تیم توسعه با کلاس‌ها و تابع‌هایی روبه‌رو می‌شود که بسیار بزرگ هستند. به همین دلیل، کار کردن با آن‌ها و تغییر دادنشان کاری سخت و پرهزینه تلقی می‌شود. معمولا به وجود آمدن این کلاس‌ها و تابع‌ها موضوعی زمان‌بر است؛ یعنی در طولانی‌مدت به وجود می‌آیند و به سامانه آسیب می‌رسانند.

- Change Preventers: اگر این بوی بد در کد احساس شود، اعمال کردن تغییرات بسیار سخت می‌شود؛ به نحوی که برای کوچکترین تغییر باید موارد خیلی زیاد و خیلی بزرگتری در کد ویرایش شوند. این بوی بد توسعه‌ی سامانه را بسیار سخت‌تر می‌کند و هزینه و زمان زیادی را از توسعه‌دهندگان می‌گیرد. پیچیدگی‌ها و ساختارهای اشتباه کد از عوامل وقوع این مشکل هستند.

- Dispencables: ممکن است در کد قطعاتی وجود داشته‌باشند که بی‌استفاده باشند؛ یعنی قطعه کدهایی که مصرفی ندارند و صرفا کد را کثیف و شلوغ ‌می‌کنند. وجود این موارد نگه‌داری از کد و همچنین پیدا کردن باگ‌های احتمالی را دشوار می‌کند.

- Couplers: اگر جفت شدن کلاس‌ها زیاد اتفاق بیفتد، نتیجه به وجود آمدن این نوع از بوی بد است. برای راحت‌تر کردن ایجاد تغییر در کد و آسیب نزدن به منطق فعلی باید تا حد امکان coupling را کاهش داد.

- Object Orientation Abusers: این نوع از بوی بد بخاطر استفاده‌ی نادرست و ناقص از اصول برنامه‌نویسی شیء‌گرا به وجود می‌آید. افزایش پیچیدگی در کد و ایجاد شدن ساختارهای اشتباه نگه‌داری از کد را بسیار سخت می‌کند.

<h3>پرسش هفتم</h3>

<p>بوی بدی که در این سوال به آن اشاره شده‌است، در دسته‌ی dispencalbes قرار می‌گیرد. برای برطرف‌کردن این بوی بد باید دست به دامن بازآرایی‌هایی شد. قطعه کدهایی که تقریبا بی‌استفاده هستند، باید با استفاده از روشی به نام in-line class treatment ویراستاری شوند. افزون بر آن، برای زیرکلاس‌هایی که تابع‌های زیادی ندارند هم باید از collapsed hierarchy استفاده کرد. گاهی اوقات این بوی بد به منظور ترسیم اهدافی که تیم توسعه باید در آینده به آن‌ها برسد، برای تیم توسعه ایجاد می شود. در موارد این‌چنینی لازم است اطمینان حاصل شود که تعادلی بین وضوح، شفافیت، و سادگی در کد برقرار است.</p>

<h3>پرسش نهم</h3>

<p> این پلاگین کد شما را به صورت خودکار فرمت می‌کند. به این ترتیب، کدتان با یک سبک خاص از کدنویسی مطابق می‌شود. این کار می‌تواند شامل تغییراتی مانند تنظیم فاصله‌ها (indentation)، فاصله‌های خالی (whitespace)، قرار دادن پرانتزها، و ... باشد. با یکسان‌سازی سبک‌های مختلف کدنویسی در یک پروژه کد خواناتر می‌شود. برخی از مواردی که استفاده از این پلاگین به آن‌ها کمک می‌کند:</p>

- صرفه‌جویی در زمان: به جای این که زمان زیادی را برای تنظیم دستی فرمت کد صرف کنید، پلاگین این کار را به صورت خودکار و در چند ثانیه انجام می‌دهد.
- یک‌نواختی: فرمت یکسان در سراسر پروژه باعث می‌شود که کد تمیزتر و حرفه‌ای‌تر به نظر برسد.
- پیش‌گیری از خطا: برخی از پلاگین‌ها می‌توانند اشتباهات رایج کدنویسی را که ممکن است به دلیل عدم دقت در فرمت‌بندی رخ دهند، کاهش دهند. البته این موضوع به رایج بودن آن اشتباه وابستگی ویژه‌ای دارد.

<p>یک تعریف برای بازآرایی آن است که شامل تغییر ساختار کد بدون تغییر در عملکرد آن را اعمال کنیم. این پلاگین می‌تواند بخشی از فرآیند بازآرایی کد باشد، زیرا به کمک مرتب‌سازی و تمیز کردن، کد را برای تغییرات آینده آماده‌تر می‌کند. به بیان دیگر، این پلاگین معمولا اولین گام در بازآرایی است؛ زیرا قبل از اعمال تغییرات اصلی و بزرگ بهتر است کد به خوبی فرمت و سازماندهی شود.</p>