# HW-6
Facade Design Pattern

Facade یک الگوی طراحی ساختاری است که یک رابط ساده‌شده برای یک کتابخانه، یک چارچوب، یا هر مجموعه پیچیده‌ای از کلاس‌ها فراهم می‌کند. ما دو بخش از کد را شناسایی کرده‌ایم که می‌توانند با استفاده از این الگو بازسازی شوند:

CodeGeneratorFacade

قبل از بازسازی، کلاس Parser به طور مستقیم از قابلیت‌های کلاس codeGenerator استفاده می‌کرد. پس از بازسازی، ما یک Facade برای CodeGenerator اضافه کردیم تا کلاس Parser تنها از قابلیت‌های موجود در کلاس CodeGeneratorFacade استفاده کند و به این ترتیب رابط موجود را محدود و ساده کردیم. در نهایت، ما همچنین استفاده‌ها را تغییر دادیم تا کد را با اقدامات بازسازی هماهنگ کنیم.

ScannerFacade

قبل از بازسازی، کلاس Parser به طور مستقیم از قابلیت‌های lexicalAnalyzer استفاده می‌کرد. پس از بازسازی، ما یک Facade برای scanner اضافه کردیم تا کلاس Parser تنها از قابلیت‌های موجود در کلاس ScannerFacade استفاده کند و به این ترتیب رابط موجود را محدود و ساده کردیم. در نهایت، ما همچنین استفاده‌ها را تغییر دادیم تا کد را با اقدامات بازسازی هماهنگ کنیم.

Polymorphism:

در زبان‌های برنامه‌نویسی و نظریه نوع‌ها، Polymorphism به فراهم کردن یک رابط واحد برای موجودیت‌هایی با نوع‌های مختلف یا استفاده از یک نماد واحد برای نمایش چند نوع مختلف اشاره دارد. یکی از نشانه‌های رایج بازسازی با استفاده از Polymorphism وجود سناریوهای متعدد switch case است. با توجه به این توضیح، ما این الگوی ضد را در کلاس Action شناسایی کردیم و آن را بازسازی کردیم. در این فرآیند، برای هر switch case موجود برای اکشن‌ها یک کلاس منحصر به فرد ایجاد کردیم؛ کلاس‌های shift، accept و reduce ایجاد شدند و همه این قابلیت‌های مرتبط با اکشن‌ها را به یک بسته actions منتقل کردیم. در نهایت، ما همچنین استفاده‌ها را تغییر دادیم تا کد را با اقدامات بازسازی هماهنگ کنیم.

Separate Query From Modifier:

این تکنیک بازسازی، Command و Query Responsibility Segregation را پیاده‌سازی می‌کند. این اصل به ما می‌گوید که کد مسئول دریافت داده‌ها را از کدی که چیزی را داخل یک شیء تغییر می‌دهد جدا کنیم. یکی از بوی بدهایی که در کد شناسایی شد مربوط به این الگو، در کلاس SymbolTable در تابع getNextParameter بود، جایی که مقدار پارامتر قبلی دریافت می‌شد و پارامتر بعدی در همان تابع بازبینی می‌شد. برای بهبود این فرآیند، ما تابع دیگری به نام getCurrentParamIndex اضافه کردیم تا Query را از Modifier جدا کنیم.

Self Encapsulated Field

در این روش بازسازی و در این بخش از پروژه بازسازی minijava، ما خواص کلاس را به صورت private تعریف می‌کنیم و آنها را نیز به صورت private فراخوانی می‌کنیم. ما از متدهای Getter و Setter استفاده می‌کنیم تا اطمینان حاصل شود که تمام عملیات روی خواص از طریق متدها انجام می‌شود و نه از طریق دسترسی مستقیم به خواص. ما Getter و Setter با نام‌های getterMemory و setterMemory را به کلاس symbolTable اضافه کردیم.
