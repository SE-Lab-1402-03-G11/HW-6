# HW-6


## فاز اول

### Overview
در این بخش قرار بود تا با استفاده از دو الگوی طراحی گفته شده یک سیستم اطلاع رسانی به شهروندان برای اعلام میزان فاصله و هزینه میان شهرها با استفاده از روش TDD بسازیم. ماحصل کار ما کلاس `NotificationSystem` است که شامل فیلدهای زیر می‌باشد:
- `Graph graph;`
- `State state;`
- `Strategy strategy;`
- `Integer trainSpeed;`

همچنین این کلاس دارای متدهای زیر است:
- `public void toggleDirection()`
- `public Integer calculateDistance(Node source, Node destination)`
- `public boolean existPath(Node source, Node destination, Node hatedCity)`
- `public StrategyApproach getFasterTransport(Node source, Node destination)`

حال به بررسی هر کدام از خواسته های این فاز میپردازیم:

### استفاده از الگوی طراحی State
در این سناریو تمامی یال‌های بین شهری یا در حالت یک‌طرفه قرار داشتند یا دوطرفه. بنابراین انگار برای شهر ما دو **State** (جهت‌دار، بی‌جهت) وجود داشت و براساس اینکه در کدام State هستیم، نحوه  `toggleDirection` متفاوتی برای پیاده‌سازی داشتیم. بنابراین از آنجا که شامل تعدادی State بودیم که هر یک دارای رفتار متفاوتی برای پیاده‌سازی این تابع بود، به سراغ الگوی طراحی **State** رفتیم. بنابراین یک اینترفیس `State` تعریف کردیم که دو متد `toggleDirection(Graph graph)` و `nextState()` را پیاده‌سازی کرده بود و سپس دو کلاس `UnidirectionalState` و `BidirectionalState` را با ارث‌بری از این اینترفیس پیاده‌سازی کردیم. بنابراین یک فیلد `state` در کلاس اصلی ما وجود خواهد داشت و برای پیاده‌سازی `toggleDirection` در این کلاس، دو خط `state.toggleDirection(graph)` و سپس `state = state.nextState()` اجرا می‌شوند.

### استفاده از الگوی طراحی Strategy
در این مسئله براساس خواسته کاربر که می‌خواست کوتاه‌ترین مسیر به وسیله قطار یا اتوبوس را پیدا کند، مجبور به استفاده از دو الگوریتم متفاوت جستجوی کوتاه‌ترین مسیر در گراف می‌شدیم. بنابراین از آنجا که با دو الگوریتم متفاوت که هر دو مربوط به پیدا کردن کوتاه‌ترین مسیر در گراف بودند، سروکار داشتیم و این دو خروجی یکسانی اما پیاده‌سازی متفاوتی داشتند، به سراغ الگوی طراحی **Strategy** رفتیم. بنابراین یک اینترفیس `Strategy` معرفی کردیم که متد `calculateDistance` و `existPath` را داشت و سپس دو کلاس `BusStrategy` و `TrainStrategy` را با ارث‌بری از این اینترفیس پیاده‌سازی کردیم. حال یک فیلد `strategy` در کلاس اصلی ما وجود دارد و بسته به خواسته کاربر، استراتژی مدنظر را ست کرده و خواسته کاربر را توسط استراتژی مدنظر اجرا می‌کنیم.

### استفاده از TDD
از آنجا که هر کدام از خواسته‌های این فاز یا ربطی به State داشتند یا ربطی به Strategy، ما دو فایل `StateTest` و `StrategyTest` را ساختیم و برای اضافه کردن هر فیچر به داخل کلاسمان، ابتدا تست‌های آن فیچر و تابع خالی مربوط به آن فیچر را به صورتی که کامپایل ارور نخوریم نوشتیم و سپس به نحوی آن فیچر را پیاده‌سازی کردیم که تست‌های مربوطه پاس شود. نحوه انجام این کار در کامیت‌های زده شده در ریپازیتوری مشخص است و می‌توانید با مراجعه به آن، جزئیات بیشتری را مشاهده کنید.

### اجرای برنامه
در آخر می‌توانید گراف مدنظر خود را در `main` ساخته و با تغییرات کوچکی مربوط به گراف مدنظر که در کد مشخص هستند، `main` را اجرا کنید که به شما کامند لاینی برای اجرای درخواست‌های گفته شده در سوال را می‌دهد.

## فاز دوم

---
